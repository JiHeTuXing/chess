//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Chess
//  @ File Name : GobangChess.cpp
//  @ Date : 2017/1/9
//  @ Author : limuzi
//
//


#include "GobangChess.h"
#include <QWidget>
#include<QDebug>

/**
 *构造函数与析构函数
 *
 */

///
/// \brief GobangChess::GobangChess
/// \param model 表示模式: 是单机模式还是联网模式
/// \param c     表示是哪一方颜色
/// \param pr
/// \param br
///
GobangChess::GobangChess(BaseChess::ChessModel model, bool c, short pr, short br)
    :BaseChess(model,c,GOBANG_ROW_NUM,GOBANG_COL_NUM,pr,br)
{
    this->gameType  = 1 ;
    this->_pieceNum = 0 ;
    _backgroundPix  = "" ;
    _whitePix       = NULL ;
    _blackPix       = NULL ;
    _pieceDiameter     = _pieceRadius*2 ;
    _pieceOperation = new GobangOperation ;

    _currentPiece = NULL ;

    //利用回调函数调用
    _dom = new DomDocument(GOBANG_XML_FILE_NAME) ;
    _dom->readXml(this,this->setConfig) ;

    for(int i=0; i<_rNum; ++i)
    {
        for(int j=0; j<_cNum; ++j)
        {
            points[i][j].setY(i*(_boardRadius));
            points[i][j].setX(j*_boardRadius);
        }
    }


}

GobangChess::~GobangChess()
{
    this->removeAllSteps();
    this->removeAllPieces();

    this->removeWhitePix();
    this->removeBlackPix();

    this->removeDom();

    if(_pieceOperation!=NULL)
        delete _pieceOperation ;

}


/**
 *绘制函数
 *
 */

void GobangChess::paintChess(QWidget *widget, QPainter *painter)
{
    widget = widget ;
    this->paintPiece(painter);
}

void GobangChess::paintBoard(QWidget *widget)
{
    //设置棋盘背景
    widget->setStyleSheet("border-image: url("+_backgroundPix+");");
}


void GobangChess::paintPiece(QPainter *painter)
{
    for(int i=0; i< _pieceNum; ++i)
    {
        GobangPiece* piece = (GobangPiece*)(_pieces.at(i)) ;
        //选中棋子与未选中的棋子,图片不同
        QPixmap* pix = ( piece->side() == true  ) ? _blackPix : _whitePix ;
        painter->drawPixmap(this->at(piece->rc()).x(),this->at(piece->rc()).y(),_pieceDiameter,_pieceDiameter,*pix);
    }

}


/**
 *棋子操作函数
 */

bool GobangChess::_tryToMove(QPoint point)
{
   RC rc =  this->getRcByPoint(point) ;
   if( (rc.r>_rNum-1 || rc.r <0 ) || (rc.c>_cNum-1 || rc.c <0 ) )
       return false ;
   bool flag = true ;

    if(NULL==_currentPiece)
        _currentPiece = new GobangPiece(_pieceNum,rc.r,rc.c,_pieceOperation,0,_pieceNum%2==0 ? _pieceColor: !_pieceColor);

   _pieces.append(_currentPiece);
   _pieceNum++ ;
   _currentPiece = NULL ;

   return flag ;
}

bool GobangChess::_moveAStep(Step *step)
{

}

bool GobangChess::_backAStep(Step *step)
{

}

RC GobangChess::getRcByPoint(QPoint point)
{
    short c = (short)(point.x()/_boardRadius) ;
    short r = (short)(point.y()/(_boardRadius)) ;
    return RC(r,c) ;
}


/**
 * ==================================================
 * 静态函数
 * ==================================================
 */

///
/// \brief GobangChess::setConfig
/// \param pthis 由于setConfig是静态函数
/// \param doc
///
bool GobangChess::setConfig(void *pthis, const QDomDocument* doc)
{
//    qDebug()<<doc->toString() ;

    GobangChess* cthis = (GobangChess*)pthis ;

    QDomElement root = doc->documentElement() ;
    if(root.isNull() || !root.hasChildNodes() )
        return false;

    //读取棋子半径
    QDomElement pr = root.firstChildElement(QString("PieceRadius")) ;
    QString prStr = pr.text() ;
    if(prStr.isNull() || prStr.isEmpty() )
        return false ;
    cthis->_pieceRadius =  prStr.toShort() ;
    cthis->_pieceDiameter = cthis->_pieceRadius*2 ;

    //读取棋盘半径
    QDomElement br = root.firstChildElement(QString("BoardRadius")) ;
    QString brStr = br.text() ;
    if(brStr.isNull() || brStr.isEmpty() )
        return false ;
    cthis->_boardRadius = brStr.toShort() ;

    //读取背景图片
    QDomElement bbg = root.firstChildElement(QString("BoardBackground")) ;
    QString bgStr = bbg.text() ;
    if(bgStr.isNull() || bgStr.isEmpty() )
        return false ;
    cthis->setBackgroundPix(bgStr) ;

    //读取棋子图片
    QDomElement whiteBg = root.firstChildElement(QString("WhitePieceBg")) ;
    QString whiteBgStr = whiteBg.text() ;
    if(whiteBgStr.isNull() || whiteBgStr.isEmpty() )
        return false ;
    cthis->setWhitePix(whiteBgStr);

    //读取棋子按压图片
    QDomElement blackBg = root.firstChildElement(QString("BlackPieceBg")) ;
    QString blackBgStr = blackBg.text() ;
    if(blackBgStr.isNull() || blackBgStr.isEmpty() )
        return false ;
    cthis->setBlackPix(blackBgStr);

    return true ;

}

